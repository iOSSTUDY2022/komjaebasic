# 9강 통신

1. 네트워크 통신의 종류
    - 두 가지
        1. 소켓 방식의 연결성 통신
        2. 비연결성 통신
    - 소켓 방식의 연결성 통신
        - 저수준 통신(Low-level)
        - 앱과 서버가 연결되면 한쪽에서 명시적으로 끊을 때까지 지속적으로 연결을 유지한다.
        - 재연결 필요 없이 원하는 만큼 빠르게 메세지를 주고받을 수 있다.
        - 메신저, 화상통화 등에 사용된다.
    - 비연결성 통신
        - HTTP/HTTPS 프로토콜 등을 사용해 메세지를 주고받는 방식
        - 매번 요청이 들어오면 응답을 보낸 후 바로 연결 종료
        - 비연결은 연결을 안한다는 뜻이 아니라, 연결을 유지하지 않는다는 뜻
        - 데이터를 주고받는 속도에 제약
        - 필요없는 네트워크 대역 소모를 줄일 수 있어 범용적인 모바일 서비스에 많이 쓰인다.
        - HTML을 제공하는 웹 페이지와 데이터만을 주고받도록 설계된 웹 서비스로 나뉜다.
    - 웹 서비스
        - 아키텍처 구조에 따른 구분
            1. SOAP 방식
            2. RESTful 방식
            
            —
            
            - SOAP 방식
                - HTTP/S, SMTP 등의 프로토콜을 통해 양쪽에서 XML 형태의 메세지를 주고받도록 구현된 프로토콜
                - Envelope/Header/Body 세 가지 영역으로 구분한다.
                - 장점
                    - SOAP를 사용한 HTTP는 기존 원격 기술들과 달리 프락시나 방화벽과 관계없이 쉽게 통신할 수 있다.
                    - SOAP가 사용하는 표준 전송 프로토콜은 HTTP이지만 이외에도 사용할 수 있는 프로토콜이 다양하다.
                    - 플랫폼 독립적인 통신이므로 시스템이 바뀌거나 이기종 플랫폼 간의 데이터 통신이 편리하다.
                    - 프래그래밍 언어에 종속되지 않는다.
                    - 매우 간단하고 확장이 용이하다.
                - 상대적으로 느리지만 일반적인 데이터 교환에선 크게 문제는 없다.
            - RESTful 방식
                - REST는 월드 와이드 웹과 같은 분산 하이퍼 미디어 시스템을 위한 소프트웨어 아키텍처의 한 형식
                - 실질적인 네트워크 프로토콜은 아니다.
                웹 형식을 빌어 데이터를 전송하되, SOAP나 쿠키 등 별도의 전송프로토콜 없이 전송하기 위해 만들어진 간단한 형식의 인터페이스.
                - REST의 데이터 구조는 굉장히 간단해, HTTP 프로토콜을 바탕으로 필요한 데이터를 별도의 규약 없이 주고받기만 하면 됩니다.
                - REST 원리를 따라 구현된 시스템이 RESTful
                - 네트워크 서버 뿐 아니라 일반 웹 서버를 통해서도 약간의 설정으로 쉽게 구현할 수 있다.
                - 서버에게 요청하려는 정보를 URI를 통해서 나타낸다.
                - RESTful API와 HTTP 전송 방식
                    - CRUD
                        - 일반적으로 서버에 요청하는 정보의 타입
                        - Create(쓰기), Read(읽기), Update(수정), Delete(삭제)
                    - URI 구성 권고는 RESTful API 구성을 위한 URI에는 정보의 분류 체계(movie/2014/action...)만 포함되어야지 정보를 어떻게 다룰 것인가하는 동작의 ㅕㅇ세는 포함하지 않는것이 좋다.
                    → 그 대신 HTTP 메소드를 사용하여 액션 구분할 것 권장
                    - HTTP 메소드 종류
                        - 여러가지 있지만 주로 사용하는건 GET/POST
                        - GET : 특정 리소스의 대표적인 정보를 요청할 때
                        - POST : ID 없이 리소스를 생성하거나 수정할 때
                    - URI에 CRUD를 포함하는 대신, URI 헤더에 메소드를 사용하여 동작을 정의
        - 응답 데이터 형식에 따른 구분
            1. XML 방식
            2. JSON 방식
            
            —
            
            - XML 방식
                - 요청 방식에 대한 응답 데이터를 XML 포맷으로 제공한다.
                - 데이터는 보통 구분을 위해 집합으로 반환해야 하고, 이를 특수 포맷으로 구성하기 때문.
                - XML
                    - W3C에서 권장하는 다목적 마크업 언어
                    - 서로 다른 시스템에서 인터넷을 통하여 데이터를 주고받을 수 있도록 고안
                    - HTML의 한계 극복 목적
                    - 태그라 불리는 마크업과 내용으로 구성
                    - 계층 구조
                - 장점 : 시스템에 의존적이지 않은 마크업 형식을 통해 데이터 교환의 표준으로 삼을 수 있다.
                - 단점 : 마크업 태그때문에 데이터 전체 용량이 커진다.
                - 파싱Parsing
                    - XML 형식의 데이터는 사용하기 위해 데이터 형식에 맞게 분석하는 과정 필요.
                    - iOS에선 파운데이션 프레임워크가 해당 파서Parser 역할 담당
            - JSON 방식
                - 경량의 데이터 교환 형식
                - JavaScript Object Notation, 즉 JS에서 출발.
                - 데이터 종류를 크게 두 가지로 구분
                    
                    
                    | 명칭 | 구분 | 형식 |
                    | --- | --- | --- |
                    | JSON 객체 | 여러 속성을 정의하는 순서 없는 집합 | { 키 : 값, 키 : 값...) |
                    | JSON 배열 | 비슷한 객체가 반복 나열되는 순서화된 리스트 | [ 객체1, 객체2, 객체3... ] |
                - JSON 객체
                    - 사전식 데이터 집합(키-값의 형태)
                    - 보편적인 데이터구조이기 때문에, 대부분 프로그래밍 어너에서 제공하는 자료 구조와 호환이 가능하다.
                        - 스위프트에서는 딕셔너리 제공. (단, 동일타입만 저장 가능)
                        - 여러 타입들을 함께 쓰기 위해선 NSDictionary, NSMutableDictionary 사용.
                        (Mutable은 객체 생성 후 수정/삭제 가능.)
                    - 데이터가 많아지면 가독성이 떨어진다.
                    → 유효성 검사와 정렬 서비스 사용(http://jsonlint.com)
                    - JSON 객체 안에 또다른 JSON 객체를 넣을 수 있다.
                - JSON 배열
                    - 순서index를 가지는 값들의 집합
                    - 여러 개의 정보를 목록식으로 보여준다.
                    - JSON 배열 내부에 들어가는 항목을 아이템item이라 부른다.
                - JSON 배열에 JSON 객체를 넣을 수 있고, 반대도 가능하고, 중첩도 가능하다.
                
2. 오픈 API를 통해 네트워크 불러오기
    - 페이징Paging : 데이터 소스 전체를 한꺼번에 전달하는 것이 아니라, 총 개수와 당장 화면에 출력하는 데이터만 전송하고, 나머지는 더보기 버튼 등을 통해 전송한다.
    1. viewDidLoad 메소드에 REST API 호출
        1. 호핀 API 호출을 위한 URI 생성
            1. REST API 호출에 필요한 네트워크 주소는 URL 객체 타입으로 필요하다.
            2. 파운데이션 프레임워크의 URL 클래스 이용 : 문자열 형태의 네트워크 주소를 인자값으로 받아 파운데이션 프레임워크 형식의 주소 객체를 사용한다. 
            3. let apiURI: URL! = URL(string: 주소)
        2. REST API 호출
            - POST 방식과 GET 방식에 따라 방법이 다르다.
            - GET은 간단 : var list = Data(contentsOf: URL타입의 객체)
            - Data()
                - 파운데이션 프레임워크 클래스.
                - 텍스트기반 뿐 아니라 이미지나 동영상 등의 바이너리 데이터도 가능
                - Data(conentsOf: url객체)
                    - GET 방식으로 RESTful 서비스 호출 및 응답 지원
                    - 잘못된 url일 수 있기에 반환값은 옵셔널 타입
            - let apiData = try! Data(contentsOf: apiURI)
                1. 입력받은 url객체로 네트워크 통신
                2. 응답받은 데이터를 Data() 객체에 저장
                3. 이를 apiData 상수에 저장
            - 주의 : http:// 는 [https://와](https://와) 달리 SSL 보안 프로토콜 적용 안됨. 
            → ATS 설정 필요(info.plist 에서 NSAllowsArbitraryLoads 값 true)
        3. 데이터 전송 결과 로그로 출력
            - (필수 코스 아님. 그냥 잘 통신되고 있나 확인용)
            - NSString(data:Inconding:)
                - Data 타입을 입력받아 원하는 인코딩 타입의 문자열로 변환
                - Data 객체 자체의 데이터는 형태가 다르기 때문
                - 옵셔널 값 반환
                - 그냥 String은 Data 타입 지원 안함. 주의 필요.
            - let log = NSString(data: apiData, encoding: String.Encoding.utf8.rawValue) ?? “”
            NSLog(”Result = \(log)”)
    2. 전달받은 데이터 파싱 후 출력
        - viewDidLoad에 이어서 추가
        1. JSON 객체를 파싱 후 NSDictionary 객체로 변환
            - 로그출력 → NSString 로 타입변경 후 NSLog 했던 것처럼
            테이블 구성용 데이터 → NSDictionary 로 타입변경 후 jsonObject 포맷
            (테이블 구성용 리스트 데이터 → NSArray 로 타입변경 후 JSONArray 포맷)
        2. 데이터 파싱: 
            - JSONSerialization.jsonObject()
            - 두 개의 인자값 : 파싱 데이터 / 파싱 옵션
            - jsonObject() 는 오류 발생하면 예외 설정 해야 함
            → do ~ try ~ catch 구문으로 감싸주기
            - jsonObject는 NSDictionary, NSArray 모두 반환 가능
        3. 데이터 구조에 따라 차례대로 캐스팅하며 읽어오기
            - 해당 JSON 데이터 구조에 따라 단계적으로 접근 필요
            - 최상위 JSON캐싱 파싱 객체(여기선 apiDictionary)에서 값을 읽은 후, 새로운 객체에 NSDictionary 타입으로 캐스팅하며 대입.
            let hoppin = apiDictionary[”hoppin”] as! NSDictionary
            - 이후 hoppin 객체에서 마찬가지로 원하는 키를 읽은 후 새로운 상수에 저장
        4. 순회처리Iterator
            - 배열을 순회처리하며 데이터를 차례로 객체로 생성한 다음 list 배열에 추가
            - for in 구문 이용해 객체를 만들고 이를 self.list에 담는다.
            - 순회 상수에 할당되는 값들이 NSDictionary 타입으로 정의하여 필요한 값들을 읽어온다.
            - 읽어오는 값 타입은 Any 이므로, 각 프로퍼티에 맞게 캐스팅해준다.
        5. 섬네일 처리
            - 이전 UIImage(named:)를 통해 데이터파일로 읽어온 섬네일도 네트워크처리 필요
            - UIImage(data:) 는 Data 타입의 인자값을 받을 수 있다.
            1. 섬네일 경로를 인자값으로 하는 URL 객체 생성
            2. 이를 Data 객체에 저장
            3. UIImage 객체를 생성해 아울렛변수의 image 속성에 대입
        6. 더보기 기능 구현
            - 파레토의 법칙 : 상위 20%의 데이터가 전체 사용 비율의 80% 차지
            1. 메인 클래스에 page 프로퍼티 추가 후 초기값을 1로 설정
            (맨 처음 소환하는 데이터 페이지를 1로 지정하는 것)
            (메인 클래스의 프로퍼티로 선언해야 값 유지)
            2. 액션 버튼 메소드에 버튼이 동작할 때마다 페이지 수 1씩 증가 설정
            3. 위에서 증가한 페이지 수를 URI(url)에 대입
            4. 기존 API 호출 구문들 작성
            5. 마지막 갱신 처리
                - 테이블 뷰는 데이터 소스 자동 갱신 안함
                (여기선 tableView(_:numberOfRowInSection:)
                - reloadData(): 추가된 데이터를 테이블뷰가 갱신하기 위한 메소드
        7. 더보기 버튼 숨김 처리
            - 지금까지 읽어온 데이터의 개수가 전체 데이터와 같으면 버튼 숨김 처리
            1. 버튼의 아울렛 변수 추가
            2. 전체 데이터 카운트 얻기
            3. 전체 데이터 카운트가 현재 읽어온 카운트(self.list.count)보다 작거나 같을 경우 더보기 버튼 생략
    - 예시
```swift
//
//  ListViewController.swift
//  MyMovieChart-1
//
//  Created by 이형주 on 2022/05/12.
//

import Foundation
import UIKit

class ListViewController: UITableViewController{

    var page = 1
    
//테이블 뷰 구성 리스트
    lazy var list: [MovieVO] = {
        var dataList = [MovieVO]()
        return dataList
    }()
    
    @IBOutlet var moreBtn: UIButton!
   
// 더보기 버튼 호출 메소드
    @IBAction func more(_ sender: Any) {
        self.page += 1
        self.callMovieAPI()
        self.tableView.reloadData()
    }
    
// 메인 작업. 데이터 불러오는 차이밍은 뷰가 처음 메모리에 호출될 때.
    override func viewDidLoad() {
        self.callMovieAPI()
    }
    
// 영화 차트 API 를 호출하는 메소드. 따로 지정.(버튼과 viewDidLoad에 중복되기 때문)
    func callMovieAPI() {
        
// 호핀 API 호출을 위한 URI 생성
        let url = "http://swiftapi.rubypaper.co.kr:2029/hoppin/movies?version=1&page=\(self.page)&count=10&genreId=&order=releasedateasc"
        let apiURI: URL! = URL(string: url)

// REST API 호출
        let apiData = try! Data(contentsOf: apiURI)

// 데이터 전송 결과 로그로 출력 (필수 아님)
        let log = NSString(data: apiData, encoding: String.Encoding.utf8.rawValue) ?? ""
        NSLog("Result = \(log)")

// JSON 객체를 파싱해 NSDictionary 객체로 변환        
        do {
            let apiDictionary = try JSONSerialization.jsonObject(with: apiData, options: []) as! NSDictionary
            
// 데이터 구조에 따라 캐스팅
            let hoppin = apiDictionary["hoppin"] as! NSDictionary
            let movies = hoppin["movies"] as! NSDictionary
            let movie = movies["movie"] as! NSArray
            
// 순회처리 하면서 API를 MovieVO 객체에 저장
            for row in movie {
// 순회 상수를 NSDictionary 타입으로 캐스팅
                let r = row as! NSDictionary
                
//테이블 뷰 리스트를 구성할 형식
                let mvo = MovieVO()
                
// movie 배열의 각 데이터를 mvo 상수의 속성에 대입
                mvo.title = r["title"] as? String
                mvo.description = r["genreNames"] as? String
                mvo.thumbnail = r["thumbnailImage"] as? String
                mvo.moreInfo = r["linkUrl"] as? String
                mvo.rating = (r["ratingAverage"] as! NSString).doubleValue
                
// 리스트 배열에 추가
                self.list.append(mvo)

// 지금까지 읽어온 데이터가 데이터 총 개수보다 많으면 더보기 버튼 숨기기
                let totalCount = (hoppin["totalCount"] as? NSString)!.integerValue
                if (self.list.count >= totalCount) 
                    self.moreBtn.isHidden = true
                }
            }
            
        } catch { }
        
    }
    
    
    override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return self.list.count
    }
    
    override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let row = self.list[indexPath.row]
        let cell = tableView.dequeueReusableCell(withIdentifier: "ListCell") as! MovieCell
        
        cell.title?.text = row.title
        cell.desc?.text = row.description
        cell.releaseDate?.text = row.releaseDate
        cell.rating?.text = "\(row.rating!)"

// 네트워크에서 이미지를 가져오기 위해 URL 생성
        let url: URL! = URL(string: row.thumbnail!)
        let imageData = try! Data(contentsOf: url)

//스토리보드 이미지 객체와 UIImage로 연결
        cell.thumbnail.image = UIImage(data: imageData)

        return cell
    }
    
    override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        NSLog("선택된 행은 \(indexPath.row)번째 행 입니다.")
    }
    

    
    
}
```
