# 10강 테이블뷰2:동작원리

- iOS 재사용 메커니즘
    - 테이블 뷰는 화면에 당장 표시할 만큼의 셀만 만들고 나머지는 스크롤로 인해 새로운 셀이 나타나야 할 때마다 그때그때 생성한다.
    - 화면을 벗어나게 된 기존 셀들은 테이블 뷰에서 제거한 후 재사용을 위해 큐에 저장한다.
    - 새로운 셀이 필요할 경우, 큐에 저장된 셀이 있는지 확인하고 있으면 재사용, 없으면 새로 생성한다.
    - 단, 재사용 큐에 저장된 셀 자체는 재사용하지만 셀의 콘텐츠는 매번 cellForRowAt을 실행해 새롭게 구성한다.
    - cellForRowAt : 테이블 뷰가 화면에 나타날 셀 객체를 데이터 소스에 요청할 때 사용하는 메소드
    - tableView.dequeueReusableCellWithIndentifier(”셀ID”) a!sa MvieCell : 재사용 큐에서 사용 가능한 셀을 확인하고, 없으면 새로 만들어 반환하는 메소드
    - 주의해야 할 원칙들
        - 반복적으로 호출되는 메소드 내부에는 네트워크 통신 등 처리 시간이 긴 로직 포함하지 않는다.
        - 네트워크 통신을 통해 읽어온 데이터는 재사용할 수 있도록 캐싱Caching 처리하여, 될 수 있으면 네트워크 통신 횟수를 줄인다.
        - 네트워크 통신이나 시간이 오래 걸리는 코드를 처리할 땐 비동기로 처리하는 것이 바람직하다.
    - 메모이제이션Memoization
        - 프로그램이 동일한 계산을 반복해야 할 때 이전에 계산한 값을 메모리에 저장함으로써 반복 수행을 제거하고 프로그램의 실행 속도를 빠르게 하는 기술
        - 해당 예제에서 메모이제이션 수정 목표
            - 기존 이미지를 불러오는 코드의 위치를 cellForRowAt 메소드에서 callMovieAPI 메소드의 API데이터 호출 다음 위치로 변경
        - 해당 예제에서 메모이제이션 수정 순서
            1. 이미지를 저장할 변수를 MovieVO 객체에 추가
            2. callMovieAPI 메소드에 웹상에 있는 이미지를 읽어와 UIImage 객체로 생성하는 코드 작성
            3. cellForRowAt 메소드에서 미리 내려받은 이미지를 배열에서 꺼내는 방식을 사용하기 위해, 이미지 객체를 대입
        - 예제
            
            ```swift
            //
            //  MovieVO.swift
            //  MyMovieChart-1
            //
            //  Created by 이형주 on 2022/05/12.
            //
            
            import Foundation
            import UIKit  // UIImage는 UIKit에 포함되어있음... 추가 필요
            
            class MovieVO {
                var thumbnail: String?
            //...중략...    
                var thumbnailImage: UIImage?
            }
            ```
            
            ```swift
            //
            //  ListViewController.swift
            //  MyMovieChart-1
            //
            //  Created by 이형주 on 2022/05/12.
            //
            func callMovieAPI() {
                    
            // ...중략...
                    
                    do {
            // ...중략...
                        for row in movie {
                            let r = row as! NSDictionary
            // ...중략...
                            let url:URL! = URL(string: mvo.thumbnail!)
                            let imageData = try! Data(contentsOf: url)
                            mvo.thumbnailImage = UIImage(data: imageData)
                            
                            self.list.append(mvo)
            // ...중략...
                            }
                        }
                        
                    } catch { }
                    
                }
            
            // ...중략...
            
            override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
                    let row = self.list[indexPath.row]
                    
            // ...중략...
            
                    cell.thumbnail.image = row.thumbnailImage
                    
                    return cell
                }
            ```
            
        - 해당 방식 장점 : 최초 한 번만 이미지를 내려받고 화면을 스크롤에서 셀이 재구성되어도 이후로는 내려받지 않는다.
        - 해당 방식 단점 : 화면을 구성할 때 섬네일을 여러 개를 받으므로 초기 화면 로딩이 지연되고, 초기 데이터가 많을 경우 메모리 저장에 부담이 갈 수 있다.
        - 해당 방식 단점 극복 : 이미지 비동기를 통한 블로킹 처리
        
- 이미지 비동기 처리
    - 동기 방식 : 주어진 명령을 차례대로 처리. 완료될 때 까지 다음 명령으로 넘어가지 않는다.
    - 비동기 방식 : 긴 시간이 걸릴 것으로 예상하는 기능을 새로운 실행 흐름으로 만들어 실행하는 방식
    - 스위프트의 비동기 방식 구현 두 가지
        1. 델리게이트 패턴 이용
            - 네트워크 통신 자체에 국한
            - NSURLConnectionDelegate
            - 델리게이트 객체에 이미지 내려받기를 위임하고, 완료되면 델리게이트 객체가 특정 메소드를 호출해 정의한다.
        2. 비동기 함수
            - DispatchQueue.main.async()
            - 디스패치 큐를 생성해 비동기 실행 흐름을 만들고, 그 위에서 코드가 독립적으로 실행
    - 비동기 방식과 메모에제이션 동시 사용
        - 비동기 기법 : 이미지를 내려받을 때를 위한 처리
        - 메모이제이션 : 테이블 뷰에서 제거된 셀이 재사용 큐에 의해 다시 구성될 때를 위한 처리
    - 예제
        
        ```swift
        
        // 섬네일 이미지를 처리하는 커스텀 메소드를 정의하고, 이 메소드 내부에서 메모이제이션 기법 적용
        func getThumbnailImage(_ index: Int) -> UIImage {
        
        // 인자값으로 받은 인덱스를 기반으로 해당하는 배열 데이터를 읽어옴
                let mvo = self.list[index]
                
        // 메모이제이션 : 저장된 이미지가 있으면 그것을 반환하고 없을 경우 내려받아 저장한 후 반환
                if let savedImage = mvo.thumbnailImage {
                    return savedImage
                } else {
                    let url: URL! = URL(string: mvo.thumbnail!)
                    let imageData = try! Data(contentsOf: url)
        // UIImage를 MovieVO 객체에 우선 저장
                    mvo.thumbnailImage = UIImage(data: imageData)
        
        // 저장된 이미지를 반환
                    return mvo.thumbnailImage!
                }
            }
        ```
        
        ```swift
        override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
                let row = self.list[indexPath.row]
                
                NSLog("제목: \(row.title!), 호출된 행 번호: \(indexPath.row)")
                
                let cell = tableView.dequeueReusableCell(withIdentifier: "ListCell") as! MovieCell
                
                cell.title?.text = row.title
                cell.desc?.text = row.description
                cell.releaseDate?.text = row.releaseDate
                cell.rating?.text = "\(row.rating!)"
        
        // 기존 구문 : cell.thumbnail.image = row.thumbnailImage
        // 수정 : 비동기 방식으로 섬네일 이미지를 읽어옴
                DispatchQueue.main.async {
                    cell.thumbnail.image = self.getThumbnailImage(indexPath.row)
                }
        // 해당 구문 클로저 특징 두 개
        // 1. 연관된 외부 변수를 그대로 사용 가능하다.
        // 2. 내부 함수에서 사용하는 외부 환경을 계속 유지해줌으로 cell 객체가 계속 살아있을 수 있다.        
                return cell
            }
        ```
        
- 일반 뷰 컨트롤러에서 테이블 뷰 사용
    - 테이블 뷰 컨트롤러는 제약 사항이 있음. 
    ex. 루트뷰가 테이블 뷰로 설정되므로 테이블 뷰의 위나 아래쪽에 다른 UI 추가 어려움.
    - 일반 뷰 컨트롤러에서 테이블 뷰 객체를 이용한 테이블 뷰 사용
        1. 테이블 뷰를 추가하고 뷰 컨트롤러와 아울렛 연결
        2. 테이블 뷰 셀도 직접 추가하고 스타일 및 ID 지정
        3. 프로토콜 익스텐션 추가
            - UITableViewDelegate
                - 테이블에서 발생하는 액션/이벤트와 관련된 메소드 정의
                - tableView(_:didSelectRowAt:)
            - UITableViewDataSource
                - 테이블을 구성하기 위해 필요한 메소드 정의
                - tableView(_:numberOfRowsInSection:)
                - tableView(_:cellForRowAt:)
        4. 클래스에 객체 참조 정보 제공
            - 클래스에 dataSource나 delegate를 사용하는 객체가 추가되면, 이들 객체가 필요한 메소드를 어디서 찾을 수 있는지에 대한 객체 참조 정보를 알려주어야 한다.
            - self.tableView.dataSource = self
            - self.tableView.delegate = self
            - (여기서 tableView는 위에 아울렛 변수로 연결한 테이블 뷰)
    - 예제
     ```swift
//
//  ViewController.swift
//  MyMovieChart-SpinOff-1
//
//  Created by 이형주 on 2022/05/17.
//

import UIKit

class ViewController: UIViewController {
    @IBOutlet weak var tableView: UITableView!
    override func viewDidLoad() {
        super.viewDidLoad()
        self.tableView.delegate = self
        self.tableView.dataSource = self
    }
}

extension ViewController: UITableViewDelegate{
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        NSLog("\(indexPath.row)번째 데이터가 클릭됨")
    }
}

extension ViewController: UITableViewDataSource{
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return 5
    }
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let cell = tableView.dequeueReusableCell(withIdentifier: "Cell")!
        cell.textLabel!.text = "\(indexPath.row)번째 데이터입니다."
        return cell
    }
}
```
